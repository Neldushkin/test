

Функция api_v1POST(Запрос)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Метод 			 = НРег(Запрос.ПараметрыURL["metod"]);
	ЗаголовкиЗапроса = ПривестиЗаголовкиВНижнийРегистр(Запрос);
	ПараметрыЗапроса = Запрос.ПараметрыЗапроса;
	
	user_token    = ЗаголовкиЗапроса.Получить("usertoken");
	token_master  = ЗаголовкиЗапроса.Получить("token_master");
	api_key    	  = ЗаголовкиЗапроса.Получить("apikey");
	ПараметрыJSON = ПолучитьПараметрыJSON(Запрос);
	club_id 	  = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "club_id");
	
	Если НЕ ЗначениеЗаполнено(club_id) Тогда
		club_id = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "club");
	КонецЕсли; 
	
	ЛогироватьСобытие = Константы.ЛогироватьHTTP.Получить();
	Если ЛогироватьСобытие > 0 Тогда
		СтруктураЛогирования = СформироватьСтруктуруЛогирования(Запрос, api_key, user_token);
	КонецЕсли;
	
	СтруктураОшибки    = Неопределено;
	СтруктурнаяЕдиница = ПолучитьСтруктурнуюЕдиницу(club_id, СтруктураОшибки, Метод);
	
	Если Не ЗначениеЗаполнено(СтруктураОшибки) И Метод <> "hidden_client_auth" Тогда
		ВнешняяСистема = ПроверитьПереданныйApiKey(api_key, СтруктураОшибки, СтруктурнаяЕдиница);
	КонецЕсли;
	
	//Если Не ЗначениеЗаполнено(СтруктураОшибки) И НеобходимоПроверятьUserToken(Метод) Тогда
	//	
	//	ИскатьТокенВИсторическомРегистре = (Метод = "payment" ИЛИ Метод = "refill_deposit");
	//	ПроверятьВалидностьТокена 		 = Метод <> "payment" И Метод <> "lead";
	//	
	//	Если ЗначениеЗаполнено(token_master)
	//		И (Метод = "payment" ИЛИ Метод = "debts_payment") Тогда
	//		
	//		Плательщик = ПроверитьUserToken(token_master, ВнешняяСистема, СтруктураОшибки, ПроверятьВалидностьТокена, ИскатьТокенВИсторическомРегистре);
	//	КонецЕсли;
	//	
	//	Если Метод <> "debts_payment" ИЛИ ЗначениеЗаполнено(user_token) Тогда
	//		Клиент = ПроверитьUserToken(user_token, ВнешняяСистема, СтруктураОшибки, ПроверятьВалидностьТокена, ИскатьТокенВИсторическомРегистре);
	//	КонецЕсли;
	//	
	//	Плательщик = ?(ЗначениеЗаполнено(Плательщик), Плательщик, Клиент);
	//	
	//	Если ЗначениеЗаполнено(Плательщик)
	//		И КлиентуЗапрещеноИспользованиеВиджета(Плательщик) Тогда
	//		
	//		СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(4044);
	//	КонецЕсли;
	//	
	//КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураОшибки) Тогда
		
		РезультатОтвет = ПолучитьHTTPОтвет(СтруктураОшибки);
		
		Если ЛогироватьСобытие > 0 Тогда
			ЛогироватьЗапрос(РезультатОтвет, СтруктураЛогирования, Перечисления.СтасусыЗапросов.ЗавершенСОшибками, 400);
		КонецЕсли;
		
		Возврат РезультатОтвет;
	
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктурнаяЕдиница) Тогда
		АктуализироватьЧасовойПояс(СтруктурнаяЕдиница);
	КонецЕсли;
	
	phone 	       = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "phone");
	phone 	       = Формат(phone, "ЧГ=");
	password   	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "password");
	pass_token 	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "pass_token");
	transaction_id = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "transaction_id");
	appointment_id = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "appointment_id");
	ticket_id 	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "ticket_id");
	date 	  	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "date");
	date_time 	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "date_time");
	payment_list   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "payment_list");
	duration 	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "duration");
	service_id 	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "service_id");
	room_id 	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "room_id");
	client_id 	   = ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "client_id");
	ЭтоMobifitness = (ЗначениеЗаполнено(ВнешняяСистема) И ВнешняяСистема.ТипВнешнейСистемы = Перечисления.ТипыВнешнихСистем.МобильноеПриложениеКлиента);
	
	Если Метод = "get_user_token" Тогда
		Ответ1с = get_user_token(ПараметрыJSON, ВнешняяСистема, СтруктурнаяЕдиница, ЭтоMobifitness);
	КонецЕсли;
	
	КодОтвета      = Неопределено;
	РезультатОтвет = ПолучитьHTTPОтвет(Ответ1с, КодОтвета);
	мОтвет         = РезультатОтвет.ПолучитьТелоКакСтроку();
	
	Если ЛогироватьСобытие > 0 Тогда
		
		ВремяОкончанияОперации = ТекущаяУниверсальнаяДатаВМиллисекундах();
		ВремяВыполнения        = (ВремяОкончанияОперации - СтруктураЛогирования.ВремяНачалаОперации) / 1000;
		СтатусСобытия		   = ?(КодОтвета = 200, Перечисления.СтасусыЗапросов.Выполнен, Перечисления.СтасусыЗапросов.ЗавершенСОшибками);
		
		Если ОбщегоНазначения.ВыполнитьЛогированиеЗапроса(ЛогироватьСобытие, СтатусСобытия, ВремяВыполнения) Тогда
			ЛогироватьЗапрос(РезультатОтвет, СтруктураЛогирования, СтатусСобытия, КодОтвета);
		КонецЕсли;
		
	КонецЕсли;

	Возврат РезультатОтвет;

КонецФункции


#Область Авторизация

// Функция, возвращает pass_token.
//
Функция get_user_token(ПараметрыJSON, ВнешняяСистема, СтруктурнаяЕдиница, ОтправлятьШестизначныйКод = Ложь) Экспорт
	
	НомерТелефона = Формат(ПолучитьЗначениеИзСтруктуры(ПараметрыJSON, "phone"), "ЧГ=");
	
	Если Не ЗначениеЗаполнено(НомерТелефона) Тогда
		Возврат ПолучитьСтруктуруОшибки_v2(4000);
	КонецЕсли;
		
	СброситьКоличествоВводаКода 	= Ложь;
	СтруктураКлюча			 		= ПолучитьПоследнююЗаписьОКлючеКлиента(ВнешняяСистема, НомерТелефона);
	//СтруктураКлюча 				= ДобавитьИлиОбновитьЗапись(ВнешняяСистема, НомерТелефона, Истина,, 43200,,,,,,, СброситьКоличествоВводаКода);
	
	
	СтатусКлюча 		  			= ?(СтруктураКлюча <> Неопределено, СтруктураКлюча.Статус, Неопределено);

	Если СтатусКлюча = Неопределено Тогда 
		Возврат ПолучитьСтруктуруОшибки_v2(4028);
	Иначе
		Возврат Новый Структура("result, data", Истина, Новый Структура("user_token", СтруктураКлюча.КлючКлиента));
	КонецЕсли;
	
КонецФункции	


#КонецОбласти





#Область ДополнительныеПроцедуры

// Функция, возвращает флаг необходимости наличия токена.
//
Функция НаличиеТокенаОбязательно(Метод)
	
	Если Метод = "client"
		ИЛИ Метод = "relatives"
		ИЛИ Метод = "tickets"
		ИЛИ Метод = "deposits"
		ИЛИ Метод = "bonuses"
		ИЛИ Метод = "visits_history"
		ИЛИ Метод = "appointments"
		ИЛИ Метод = "progress" Тогда
		
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция НеобходимоПроверятьUserToken(Метод)
	
	Если Метод <> "confirm_phone"
		И Метод <> "password"
		И Метод <> "auth_client"
		И Метод <> "client"
		И Метод <> "auth_client_intellect_dialog"
		И Метод <> "reg_and_auth_client" 
		И Метод <> "webhook"
		И Метод <> "confirm_appointment"
		И Метод <> "hidden_client_auth" 
		И Метод <> "available_slots" Тогда
		
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Функция, определяет наличие запрета у клиента на использование виджета личного кабинета.
//
Функция КлиентуЗапрещеноИспользованиеВиджета(Клиент)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КонтрагентыТеги.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.Контрагенты.Теги КАК КонтрагентыТеги
	|ГДЕ
	|	КонтрагентыТеги.Ссылка = &Клиент
	|	И КонтрагентыТеги.Тег = ЗНАЧЕНИЕ(Справочник.Теги.ЗапретитьИспользованиеВиджетаЛК)");
	
	Запрос.УстановитьПараметр("Клиент", Клиент);
	
	Возврат Не Запрос.Выполнить().Пустой();
	
КонецФункции


// Функция, возвращает параметры JSON из тела запроса.
//
Функция ПолучитьПараметрыJSON(Запрос)
	
	ТекстJSON  = Запрос.ПолучитьТелоКакСтроку();	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТекстJSON);
	Возврат ПрочитатьJSON(ЧтениеJSON);
	
КонецФункции

// Функция, проверяет api_key и наличие настроенной внешней системы.
//
Функция ПроверитьПереданныйApiKey(api_key, СтруктураОшибки, СтруктурнаяЕдиница = Неопределено)
	
	Если Не ЗначениеЗаполнено(api_key) Тогда
		СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1062);
		Возврат Неопределено;
	КонецЕсли;
	
	ВнешняяСистема = Справочники.ВнешниеСистемы.ПолучитьВнешнююСистему(api_key);
	
	Если Не ЗначениеЗаполнено(ВнешняяСистема) Тогда
		
		СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1063);
		
	ИначеЕсли Не ЗначениеЗаполнено(СтруктурнаяЕдиница) Тогда
		
		api_ОбщегоНазначения.ПолучитьСтруктурнуюЕдиницуИЭквайринговыйТерминалВС(ВнешняяСистема, СтруктурнаяЕдиница);
		
		Если СтруктурнаяЕдиница = Неопределено Тогда
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1025);
		КонецЕсли;
		
	ИначеЕсли Не api_ОбщегоНазначения.НаличиеСтруктурнойЕдиницыВоВнешнейСистеме(ВнешняяСистема, СтруктурнаяЕдиница) Тогда
		СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1025);
	КонецЕсли;
	
	Возврат ВнешняяСистема;
	
КонецФункции

// Функция, возвращает результат проверки структурной единицы.
//
Функция ПолучитьСтруктурнуюЕдиницу(club_id, СтруктураОшибки, ИмяМетода)
	
	МассивМетодовОбязательныхКПроверкеСЕ = Новый Массив;
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("appointment_services");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("appointment_trainers");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("appointment_times");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("appointment_dates");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("employee_choice");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("rental_services");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("rental_rooms");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("rental_times");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("appointment");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("cart_cost");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("payment");
	МассивМетодовОбязательныхКПроверкеСЕ.Добавить("classes");
	
	ПроверятьСтруктурнуюЕдиницу = МассивМетодовОбязательныхКПроверкеСЕ.Найти(ИмяМетода) <> Неопределено;
	СтруктурнаяЕдиница 			= ПолучитьСсылкуПоИдентификатору_v3(club_id, СтруктураОшибки, Истина, "СтруктурныеЕдиницы", 1025, ПроверятьСтруктурнуюЕдиницу);
	
	Возврат СтруктурнаяЕдиница;
	
КонецФункции

// Функция, проверяет токен пользователя.
//
Функция ПроверитьUserToken(user_token, ВнешняяСистема, СтруктураОшибки = Неопределено, ПроверятьВалидностьТокена = Истина, ИскатьТокенВИсторическомРегистре = Ложь)
	
	Если Не ЗначениеЗаполнено(user_token) Тогда
		Если ПроверятьВалидностьТокена Тогда
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(4005);
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	// user_token теперь бессрочный. Брамс.
	Клиент			 = Неопределено;
	ПараметрыКлиента = РегистрыСведений.КлючиПользователейВнешнихСистем.ПолучитьПараметрыКлиентаПоВнешнейСистемеИКлючу(ВнешняяСистема, user_token);	
	
	Если ЗначениеЗаполнено(ПараметрыКлиента) Тогда
		
		Клиент = ПараметрыКлиента.Объект;
		Если Не ЗначениеЗаполнено(Клиент) Тогда 
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1010);
			Возврат Неопределено;
		КонецЕсли;
		
	ИначеЕсли ИскатьТокенВИсторическомРегистре Тогда
		
		Клиент = РегистрыСведений.КлючиПользователейВнешнихСистемИстория.ПолучитьОбъектПоКлючу(user_token);
		Если Не ЗначениеЗаполнено(Клиент) И ПроверятьВалидностьТокена Тогда
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(4005);
		КонецЕсли;
		
	ИначеЕсли ПроверятьВалидностьТокена Тогда
		СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(4005);
	КонецЕсли;
	
	Возврат Клиент;
	
КонецФункции

// Функция, помещает в массив значение.
//
Функция ПреобразоватьКМассивуВходноеЗначение(Значения)
	
	Возврат ОбщегоНазначенияКлиентСервер.ПреобразоватьЗначениеКМассиву(Значения);
	
КонецФункции

// Функция, проверяет переданное занятие.
//
Функция ПолучитьСсылкуПоИдентификатору_v3(Идентификатор, СтруктураОшибки, ЭтоСправочник, ИмяОбъекта, КодОшибки, ОбязательныйПараметр = Ложь)
	
	Возврат api_ОбщегоНазначения.ПолучитьСсылкуПоИдентификатору_v3(Идентификатор, СтруктураОшибки, ЭтоСправочник, ИмяОбъекта, КодОшибки, ОбязательныйПараметр);
	
КонецФункции

// Процедура, устанавливает часовой пояс структурной единицы.
//
Процедура АктуализироватьЧасовойПояс(СтруктурнаяЕдиница)
	
	// Часовой пояс берем из структурной единицы.
	ЧасовойПоясТекущегоСеанса 	  = ЧасовойПоясСеанса();
	ЧасовойПоясСтруктурнойЕдиницы = СтруктурнаяЕдиница.ЧасовойПояс;
	
	Если ЧасовойПоясТекущегоСеанса <> ЧасовойПоясСтруктурнойЕдиницы Тогда
		УстановитьЧасовойПоясСеанса(ЧасовойПоясСтруктурнойЕдиницы);
	КонецЕсли;
	
КонецПроцедуры

// Функция, находит или создает рекламный источник по наименованию.
//
Функция ПолучитьРекламныйИсточник_удалить(Наименование)
	
	Возврат Справочники.РекламныеИсточники.ПолучитьРекламныйИсточник(Наименование);
	
КонецФункции

// Функция, возвращает массив service_ids из параметров запроса.
// 
Функция ПолучитьМассив_service_ids(ПараметрыЗапроса)
	
	ТекстJSON = ПараметрыЗапроса.Получить("service_ids");
	
	Если ЗначениеЗаполнено(ТекстJSON) Тогда
		
		Попытка
			
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ТекстJSON);
			ПараметрыJSON = ПрочитатьJSON(ЧтениеJSON);
			
			Возврат ПараметрыJSON.services_array;
			
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции


// Функция возвращает структуру с заголовками запроса в нижнем регистре.
//
Функция ПолучитьСоответствиеЗаголовков(Запрос)
	
	СоответствиеСЗаголовками = Новый Соответствие;
	
	Для Каждого Заголовок Из Запрос.Заголовки Цикл
		СоответствиеСЗаголовками.Вставить(НРег(Заголовок.Ключ), Заголовок.Значение);
	КонецЦикла;
	
	Возврат СоответствиеСЗаголовками;
	
КонецФункции

// Функция, возвращает параметр из строки JSON.
// 
Функция ПолучитьПараметрИзСтрокиJSON(ПараметрыЗапроса, НаименованиеПараметра)
	
	ТекстJSON = ПараметрыЗапроса.Получить(НаименованиеПараметра);
	
	Если ЗначениеЗаполнено(ТекстJSON) Тогда
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТекстJSON);
		Возврат ПрочитатьJSON(ЧтениеJSON);
		
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Функция, преобразует строку в дату.
//
Функция ПолучитьДатуИзСтроки(СтроковаяДата) 
	
	Попытка
		
		СтроковаяДата = СтрЗаменить(СтроковаяДата , "-","");
		СтроковаяДата = СтрЗаменить(СтроковаяДата , ":","");
		СтроковаяДата = СтрЗаменить(СтроковаяДата , "T","");
		
		Если СтрДлина(СтроковаяДата) < 12 Тогда 
			Возврат Неопределено;
		КонецЕсли;	
		
		СтроковаяДата = ?(СтрДлина(СтроковаяДата) = 12, СтроковаяДата + "00", СтроковаяДата);
		СтроковаяДата = ?(СтрДлина(СтроковаяДата) > 14, Лев(СтроковаяДата, 14), СтроковаяДата);
		
		Возврат Дата(СтроковаяДата);
		
	Исключение
		Возврат Неопределено;		
	КонецПопытки;
	
КонецФункции


// Функция возвращает структуру с заголовками запроса в нижнем регистре.
//
Функция ПривестиЗаголовкиВНижнийРегистр(Запрос)
	
	СоответствиеСЗаголовками = Новый Соответствие;
	
	Для Каждого Заголовок Из Запрос.Заголовки Цикл
		СоответствиеСЗаголовками.Вставить(НРег(Заголовок.Ключ), Заголовок.Значение);
	КонецЦикла;
	
	Возврат СоответствиеСЗаголовками;
	
КонецФункции

// Функция проводит аутентификацию приложения
//
Функция ПроверитьКлючПриложения(ApiKey, ВнешняяСистема = Неопределено)
	
	Если НЕ ЗначениеЗаполнено(ApiKey) Тогда
		Возврат Новый Структура("Parameters, Errors", , ПолучитьСтруктуруВозвратаОшибки(1062, "Не указан ключ авторизации"));
	КонецЕсли;
	
	ВнешняяСистема = Справочники.ВнешниеСистемы.ПолучитьВнешнююСистему(ApiKey);
	Если НЕ ЗначениеЗаполнено(ВнешняяСистема) Тогда
		Возврат Новый Структура("Parameters, Errors", , ПолучитьСтруктуруВозвратаОшибки(1063, "Неверный ключ авторизации"));
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Функция, возвращает структуру возврата ошибки. 
//
Функция ПолучитьСтруктуруВозвратаОшибки(КодОшибки = Неопределено, ОписаниеОшибки = Неопределено)
	
	КодОшибки = ?(КодОшибки = Неопределено, 0, КодОшибки);
	Возврат Новый Структура("code, message", КодОшибки, ОписаниеОшибки);	
	
КонецФункции

// Функция - Извлечь код ошибки нижнего уровня
//
// Параметры:
//  ТекстОшибки	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция ИзвлечьКодОшибкиНижнегоУровня_удалить(знач ТекстОшибки) 
	
	Попытка 
		
		КодОшибкиИзОбъекта = Неопределено;
		
		Если СтрНайти(ТекстОшибки, "[") > 0 Тогда
			
			Начало = СтрНайти(ТекстОшибки,"[");
			Конец = СтрНайти(ТекстОшибки,"]",НаправлениеПоиска.СКонца);
			Если Начало > 0 
				И Конец > 0 Тогда
				
				КодОшибкиИзОбъекта = Сред(ТекстОшибки, Начало + 1, Конец - Начало - 1);
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "[" + КодОшибкиИзОбъекта + "]", "");
				
			КонецЕсли;
			
			Возврат Новый Структура("ТекстОшибки,КодОшибки", ТекстОшибки, Число(КодОшибкиИзОбъекта));
			
		КонецЕсли;
		
	Исключение
		
	КонецПопытки;
	
	Возврат Неопределено;
	
КонецФункции


// Функция, формирует структуру для логирования HTTP запросов.
//
Функция СформироватьСтруктуруЛогирования(Запрос, api_key = Неопределено, user_token = Неопределено, HTTPШаблон = "api_v3")
	
	СтруктураЛогирования = Новый Структура;
	СтруктураЛогирования.Вставить("ВремяНачалаОперации", ТекущаяУниверсальнаяДатаВМиллисекундах());
	СтруктураЛогирования.Вставить("UIDЗапроса"		   , Новый УникальныйИдентификатор());
	СтруктураЛогирования.Вставить("HTTPЗапросЛога"	   , Запрос);
	СтруктураЛогирования.Вставить("ДатаЛога"		   , ТекущаяДатаСеанса());
	СтруктураЛогирования.Вставить("ТипЗапроса"		   , Перечисления.HTTPСервисы.API);
	СтруктураЛогирования.Вставить("ApiKeyЛога"		   , ?(user_token = Неопределено, api_key, user_token));
	СтруктураЛогирования.Вставить("user_token"		   , user_token);
	СтруктураЛогирования.Вставить("HTTPШаблон"		   , HTTPШаблон);
	СтруктураЛогирования.Вставить("ВнешняяСистема"	   , ?(ЗначениеЗаполнено(api_key), Справочники.ВнешниеСистемы.ПолучитьВнешнююСистему(api_key), Неопределено));
	
	Возврат СтруктураЛогирования;
	
КонецФункции

// Процедура, логирует HTTP запрос.
//
Процедура ЛогироватьЗапрос(РезультатОтвет, СтруктураЛогирования, Статус, КодОтвета)
	
	ВремяОкончанияОперации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ВремяВыполнения        = (ВремяОкончанияОперации - СтруктураЛогирования.ВремяНачалаОперации) / 1000;
	мОтвет                 = РезультатОтвет.ПолучитьТелоКакСтроку();
	
	РегистрыСведений.ЖурналЗапросов.ЛогироватьЗапрос(
		СтруктураЛогирования.HTTPЗапросЛога,
		СтруктураЛогирования.ДатаЛога,
		СтруктураЛогирования.UIDЗапроса,
		СтруктураЛогирования.ТипЗапроса,
		СтруктураЛогирования.HTTPШаблон,
		Статус,
		ВремяВыполнения,
		СтруктураЛогирования.ВнешняяСистема,
		СтруктураЛогирования.ApiKeyЛога,
		мОтвет,
		РезультатОтвет.КодСостояния,
		СтруктураЛогирования.user_token,
		КодОтвета
	);
	
КонецПроцедуры


// Функция, возвращает вид цен по внешней системе.
//
Функция ПолучитьРеквизитИзНастроекApi(НастройкиAPI, НаименованиеРеквизита, ЗначениеПоУмолчанию = Неопределено)
	
	Если ТипЗнч(НастройкиAPI) = Тип("Структура") И НастройкиAPI.Свойство(НаименованиеРеквизита) И ЗначениеЗаполнено(НастройкиAPI[НаименованиеРеквизита]) Тогда
		Значение = НастройкиAPI[НаименованиеРеквизита];
	Иначе
		Значение = ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Функция, возвращает значение из структуры по ключу.
//
Функция ПолучитьЗначениеИзСтруктуры_удалить(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено)
	
	Возврат ОбщегоНазначенияКлиентСервер.ПолучитьЗначениеИзСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию);
	
КонецФункции


// Функция, возвращает ссылку по УИД.
//
Функция ПолучитьСсылкуОбъектаПоУИД_удалить(УИД, ВидОбъекта, ИмяОбъекта)
	
	Возврат api_ОбщегоНазначения.ПолучитьСсылкуОбъектаПоУИД(УИД, ВидОбъекта, ИмяОбъекта);

КонецФункции

// Функция, возвращает HTTPОтвет. 
//
Функция ПолучитьHTTPОтвет(Ответ1с, КодОтвета = Неопределено)
	
	Возврат api_ОбщегоНазначения.ПолучитьHTTPОтвет(Ответ1с, КодОтвета);
	
КонецФункции


// Функция, возвращает структуру возврата ошибки. 
//
Функция ПолучитьСтруктуруОшибки(КодОшибки = Неопределено, СтруктураПараметров = "Не использовать", ОписаниеОшибки = "")
	
	Возврат api_ОбщегоНазначения.ПолучитьСтруктуруОшибки(КодОшибки, СтруктураПараметров, ОписаниеОшибки);
	
КонецФункции

// Функция, возвращает структуру возврата ошибки. 
//
Функция ПолучитьСтруктуруОшибки_v2(КодОшибки = Неопределено, ОписаниеОшибки = "")
	
	Возврат api_ОбщегоНазначения.ПолучитьСтруктуруОшибки_v2(КодОшибки, ОписаниеОшибки);

КонецФункции

#КонецОбласти



#Область ДополнительныеПроцедурыИФункции

// Функция, возвращает последнюю запись в регистре.
//
Функция ПолучитьПоследнююЗаписьОКлючеКлиента(ВнешняяСистема, НомераТелефонов, Роль = Неопределено, Объект = Неопределено)
	
	Возврат РегистрыСведений.КлючиПользователейВнешнихСистем.ПолучитьПоследнююЗаписьОКлючеКлиента(ВнешняяСистема, НомераТелефонов, Роль, Объект);
	
КонецФункции

// Функция, добавляет запись в регистр "КлючиПользователейВнешнихСистем".
//
Функция ДобавитьИлиОбновитьЗапись(
	ВнешняяСистема,
	НомерТелефона,
	Использовать 				   = Ложь,
	КлючКлиента 				   = Неопределено,
	ДлительностьДействияТокена 	   = Неопределено,
	КодПодтверждения 			   = Неопределено,
	Объект 						   = Неопределено,
	Пароль 						   = Неопределено,
	РольПользователяВнешнейСистемы = Неопределено,
	FirebaseToken				   = Неопределено,
	Платформа					   = Неопределено,
	СброситьКоличествоВводаКода    = Ложь
	)
	
	Возврат РегистрыСведений.КлючиПользователейВнешнихСистем.ДобавитьИлиОбновитьЗапись(
		ВнешняяСистема,
		НомерТелефона,
		Использовать,
		КлючКлиента,
		?(ДлительностьДействияТокена <> Неопределено, ТекущаяДатаСеанса() + ДлительностьДействияТокена, Неопределено),
		КодПодтверждения,
		Объект,
		Пароль,
		?(ТипЗнч(Объект) = Тип("СправочникСсылка.Контрагенты"), Перечисления.РолиПользователейВнешнихСистем.Клиент, РольПользователяВнешнейСистемы),
		?(ЗначениеЗаполнено(КодПодтверждения), Перечисления.СтатусыКлючейВнешнихСистем.ОжиданиеПодтверждения, Перечисления.СтатусыКлючейВнешнихСистем.Подтвержден),
		FirebaseToken,
		Платформа,
		СброситьКоличествоВводаКода
	);
	
КонецФункции

// Функция, возвращает флаг фискализации в Сбербанке.
//
Функция ИспользуетсяФискализацияВСбербанке(ВнешняяСистема, СтруктурнаяЕдиница)
	
	ЭквайринговыйТерминал = Неопределено;
	ПолучитьСтруктурнуюЕдиницуИЭквайринговыйТерминалВС(ВнешняяСистема, СтруктурнаяЕдиница, ЭквайринговыйТерминал);
	Возврат ЭквайринговыйТерминал.ТипФискализации = Перечисления.ТипыФискализации.ВСбербанке;
	
КонецФункции

// Функция, возвращает путь к фото сотрудника.
//
Функция ПолучитьАдресФотоОбъекта(Сотрудник, КлючПриложения)
	
	РасширениеФото  = ?(ЗначениеЗаполнено(Сотрудник.ФайлКартинки), Сотрудник.ФайлКартинки.Расширение, Неопределено);
	РазмерФото      = ?(ЗначениеЗаполнено(Сотрудник.ФайлКартинки), Сотрудник.ФайлКартинки.Размер	, Неопределено);
	АдресПубликации = Константы.ВнешняяПубликацияАдрес.Получить();
	
	Если ЗначениеЗаполнено(РасширениеФото) Тогда
		Возврат АдресПубликации + "/hs/api/v2/files/" + Строка(КлючПриложения) + "/" + Сотрудник.УникальныйИдентификатор() + "-" + Формат(РазмерФото, "ЧГ=") + "." + РасширениеФото;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Функция, проверяет переданное начало периода.
//
Функция ПолучитьНачалоПериода(start_date, СтруктураОшибки, ОбязательныйПараметр = Ложь, ВозвращатьТекущуюДату = Истина)
	
	Возврат api_ОбщегоНазначения.ПолучитьНачалоПериода(start_date, СтруктураОшибки, ОбязательныйПараметр, ВозвращатьТекущуюДату);
	
КонецФункции

// Функция, проверяет переданное окончание периода.
//
Функция ПолучитьОкончаниеПериода(end_date, СтруктураОшибки, ОбязательныйПараметр = Ложь, ВозвращатьТекущуюДатуПлюсМесяц = Истина, ВозвращатьТекущуюДатуПлюсДень = Ложь)
	
	Если ЗначениеЗаполнено(end_date) Тогда
		
		ДатаОкончания = КонвертироватьСтрокуВДату(end_date);
		Если ДатаОкончания = Неопределено Тогда
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(2017);
		КонецЕсли;
		
	ИначеЕсли ОбязательныйПараметр Тогда
		СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(2017);
	ИначеЕсли ВозвращатьТекущуюДатуПлюсДень Тогда
		ДатаОкончания = ТекущаяДатаСеанса() + 60*60*24;
	ИначеЕсли ВозвращатьТекущуюДатуПлюсМесяц Тогда
		ДатаОкончания = ДобавитьМесяц(ТекущаяДатаСеанса(), 1);
	КонецЕсли;
	
	Возврат ДатаОкончания;
	
КонецФункции

// Функция, возвращает значение реквизита.
//
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита)
	
	// Неопбходимо для оптимизации. Эта функция работает быстрее, чем получение значения через точку.
	Возврат ОбщегоНазначения.ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита);
	
КонецФункции

// Функция, возвращает значение реквизита номенклатуры.
//
Функция ПолучитьЗначениеРеквизитаНоменклатуры(Ссылка, ИмяРеквизита, СтруктурнаяЕдиница, УчитыватьСтруктурнуюЕдиницу = Истина)
	
	Возврат ОбщегоНазначения.ПолучитьЗначениеРеквизитаНоменклатуры(Ссылка, ИмяРеквизита, СтруктурнаяЕдиница, УчитыватьСтруктурнуюЕдиницу);
	
КонецФункции

// Функция, возвращает номенклатуру или сегмент номенклатуры по переданному service_id.
//
Функция ПолучитьНоменклатуруИлиСегментПоИдУслуги(service_id, СтруктураОшибки = Неопределено, ИскатьТолькоНоменклатуру = Ложь)
	
	Если ЗначениеЗаполнено(service_id) Тогда
		
		УслугаСегмент = ПолучитьСсылкуОбъектаПоУИД(service_id, "Справочники", "Номенклатура");
		
		Если УслугаСегмент = Неопределено И Не ИскатьТолькоНоменклатуру Тогда
			УслугаСегмент = ПолучитьСсылкуОбъектаПоУИД(service_id, "Справочники", "СегментыНоменклатуры");
		КонецЕсли;
		
		Если УслугаСегмент = Неопределено Тогда				
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1014);
		КонецЕсли;
		
	Иначе
		УслугаСегмент = Неопределено;
	КонецЕсли;
	
	Возврат УслугаСегмент;
	
КонецФункции

// Функция, возвращает тип номенклатуры по представлению.
//
Функция ПолучитьТипНоменклатурыПоПредставлению(type, СтруктураОшибки)
	
	Если ЗначениеЗаполнено(type)Тогда
		
		Если type = "membership" Тогда
			Возврат Перечисления.ТипыНоменклатуры.АбонементЧленство;
		ИначеЕсли type = "package" Тогда
			Возврат Перечисления.ТипыНоменклатуры.АбонементПакетУслуг;
		ИначеЕсли type = "service" Тогда
			Возврат Перечисления.ТипыНоменклатуры.Услуга;
		Иначе
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1044);
		КонецЕсли;
		
	КонецЕсли;
		
	Возврат Неопределено;
	
КонецФункции

Функция ПолучитьНормуВремениУслугиВСекундах(Услуга)
	
	Возврат Справочники.Номенклатура.ПолучитьНормуВремениВСекундах(Услуга);
	
КонецФункции

// Функция, возвращает таблицу бонусных счетов с остатками.
//
Функция ПолучитьБонусныеСчетаСОстатками(Клиент)
	
	Возврат api_ОбщегоНазначения.ПолучитьБонусныеСчетаСОстатками(Клиент);
	
КонецФункции

// Функция, проверяет доступность по времени членства пакета услуг.
//
Функция ЧленствоПакетУслугДоступноПоВремениДействия(ОграничениеПоВремениДействия, ТаблицаВремяДействия, ДатаНачала, ДатаОкончания)
	
	Возврат api_ОбщегоНазначения.ЧленствоПакетУслугДоступноПоВремениДействия(ОграничениеПоВремениДействия, ТаблицаВремяДействия, ДатаНачала, ДатаОкончания);
	
КонецФункции

Функция ПолучитьТолькоВремяИзДаты(ДатаВремя)
	
	Возврат Дата(1, 1, 1) + (ДатаВремя - НачалоДня(ДатаВремя));
	
КонецФункции

// Функция, возвращает вид цен сотрудника по структурной единице.
//
Функция ПолучитьВидЦенСотрудникаПоСтруктурнойЕдинице(Сотрудник, СтруктурнаяЕдиница)
	
	Возврат Справочники.Сотрудники.ПолучитьВидЦенСотрудникаПоСтруктурнойЕдинице(Сотрудник, СтруктурнаяЕдиница);
	
КонецФункции

Функция ПолучитьТекстУсловияПробныеПакетыУслуг(Клиент)
	
	Возврат api_ОбщегоНазначения.ПолучитьТекстУсловияПробныеПакетыУслуг(Клиент);
	
КонецФункции

// Функция, создает документ "Реализация".
//
Функция СозданиеРеализациюИВыполнитьВсеРасчеты(
			Клиент,
			МассивСтруктурНоменклатур,
			СтруктурнаяЕдиница, 
			ВнешняяСистема = Неопределено, 
			Организация = Неопределено, 
			Промокод = Неопределено,
			ТЧПоТипамПродления = Неопределено)
	
	Возврат api_ОбщегоНазначения.СозданиеРеализациюИВыполнитьВсеРасчеты(
				Клиент,
				МассивСтруктурНоменклатур,
				СтруктурнаяЕдиница,
				ВнешняяСистема,
				Организация, 
				Промокод,
				ТЧПоТипамПродления);
	
КонецФункции

// Функция, создаёт поступление денежных средств для взноса на лицевой счёт.
//
Функция СоздатьВзносНаЛицевойСчет(СтруктурнаяЕдиница, Клиент, ТипОплаты, ЛицевойСчет, ЭквайринговыйТерминал, КассаОплаты = Неопределено, ИдТранзакции, СуммаДокумента)
	
	Возврат api_ОбщегоНазначения.СоздатьВзносНаЛицевойСчет(СтруктурнаяЕдиница, Клиент, ТипОплаты, ЛицевойСчет, ЭквайринговыйТерминал, КассаОплаты, ИдТранзакции, СуммаДокумента);
	
КонецФункции

// Функция, создаёт поступление денежных средств.
//
Функция СоздатьПоступлениеДенежныхСредств(Клиент, ТипОплаты, Реализация, ЭквайринговыйТерминал, КассаОплаты, ИдТранзакции, СуммаДокумента, Плательщик)
	
	СтруктурнаяЕдиница = Реализация.СтруктурнаяЕдиница;
	Возврат api_ОбщегоНазначения.СоздатьПоступлениеДенежныхСредств(Клиент, СтруктурнаяЕдиница, ТипОплаты, Реализация, ЭквайринговыйТерминал, КассаОплаты, ИдТранзакции, СуммаДокумента, Плательщик);
	
КонецФункции

// Функция, возвращает структуру интервала.
//
Функция СформироватьСтруктуруИнтервала(ДатаВремяНачала, ДатаВремяОкончания, Сотрудник = Неопределено, МинНормаВремениПоСотруднику = 0, Помещение = Неопределено)
	
	СтруктураИнтервала = Новый Структура;
	СтруктураИнтервала.Вставить("ДатаВремяНачала"			 , ДатаВремяНачала);
	СтруктураИнтервала.Вставить("ДатаВремяОкончания"		 , ДатаВремяОкончания);
	
	Если Помещение <> Неопределено Тогда
		СтруктураИнтервала.Вставить("МинНормаВремени"			 , МинНормаВремениПоСотруднику);
		СтруктураИнтервала.Вставить("Помещение"					 , Помещение);
	Иначе
		СтруктураИнтервала.Вставить("МинНормаВремениПоСотруднику", МинНормаВремениПоСотруднику);
		СтруктураИнтервала.Вставить("Сотрудник"					 , Сотрудник);
	КонецЕсли;
	
	Возврат СтруктураИнтервала;
	
КонецФункции

// Функция, определяет, что тип номенклатуры является пакетом услуг или членством.
//
Функция ЭтоЧленствоПакетУслуг(ТипНоменклатуры)
	
	Возврат ТипНоменклатуры = Перечисления.ТипыНоменклатуры.АбонементПакетУслуг ИЛИ ТипНоменклатуры = Перечисления.ТипыНоменклатуры.АбонементЧленство;
	
КонецФункции

// Функция, возвращает таблицу долгов.
//
Функция ПолучитьТаблицуДолгов(Клиент, МассивОрганизаций, МассивРеализаций = Неопределено)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	РасчетыСПокупателямиОстатки.Основание.Дата КАК Период,
	|	РасчетыСПокупателямиОстатки.Основание КАК Основание,
	|	ЕСТЬNULL(РасчетыСПокупателямиОстатки.СуммаОстаток, 0) КАК Сумма,
	|	ЕСТЬNULL(РасчетыСПокупателямиОстатки.Основание.ОплачиваетсяВРассрочку, ЛОЖЬ) КАК ОплачиваетсяВРассрочку,
	|	РасчетыСПокупателямиОстатки.Основание.СуммаДокумента КАК СуммаДокумента,
	|	СхемыРассрочек.ДатаПлатежа КАК ДатаПлатежа,
	|	СхемыРассрочек.СуммаПлатежа КАК СуммаПлатежа
	|ИЗ
	|	РегистрНакопления.РасчетыСПокупателями.Остатки(
	|			,
	|			Контрагент = &Клиент
	|				И ТипРасчета В (ЗНАЧЕНИЕ(Перечисление.ТипыРасчетов.Долг), ЗНАЧЕНИЕ(Перечисление.ТипыРасчетов.ПредварительныйДолг), ЗНАЧЕНИЕ(Перечисление.ТипыРасчетов.Рассрочка))
	|				И &УсловиеМассивОрганизаций
	|				И &УсловиеМассивРеализаций) КАК РасчетыСПокупателямиОстатки
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СхемыРассрочек КАК СхемыРассрочек
	|		ПО РасчетыСПокупателямиОстатки.Основание = СхемыРассрочек.Основание
	|			И (СхемыРассрочек.ДатаПлатежа < &ТекущаяДата)
	|ГДЕ
	|	НЕ РасчетыСПокупателямиОстатки.Основание.Дата ЕСТЬ NULL
	|	И (РасчетыСПокупателямиОстатки.СуммаОстаток <= 0
	|			ИЛИ РасчетыСПокупателямиОстатки.КоличествоОстаток < 0)
	|
	|УПОРЯДОЧИТЬ ПО
	|	Период
	|ИТОГИ ПО
	|	Основание");
	
	Запрос.УстановитьПараметр("Клиент"	   		 , Клиент);
	Запрос.УстановитьПараметр("МассивОрганизаций", МассивОрганизаций);
	Запрос.УстановитьПараметр("МассивРеализаций" , МассивРеализаций);
	Запрос.УстановитьПараметр("ТекущаяДата"		 , ТекущаяДатаСеанса());
	
	УсловиеМассивОрганизаций = ?(ЗначениеЗаполнено(МассивОрганизаций), "И Организация В (&МассивОрганизаций)", "");
	Запрос.Текст 	  		 = СтрЗаменить(Запрос.Текст, "И &УсловиеМассивОрганизаций", УсловиеМассивОрганизаций);
	
	УсловиеМассивРеализаций  = ?(ЗначениеЗаполнено(МассивРеализаций), "И Основание В (&МассивРеализаций)", "");
	Запрос.Текст 	   		 = СтрЗаменить(Запрос.Текст, "И &УсловиеМассивРеализаций", УсловиеМассивРеализаций);
	
	Возврат Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкам);
	
КонецФункции

// Функция, проверяет переданный массив покупок.
//
Функция ПроверитьМассивСтруктурНоменклатур(cart_array, ПереданныйВидЦен = Неопределено, СтруктураОшибки, ПараметрыВнешнейСистемы = Неопределено, СтруктурнаяЕдиница = Неопределено, Клиент = Неопределено)
	
	Возврат api_ОбщегоНазначения.ПроверитьМассивСтруктурНоменклатур(cart_array, ПереданныйВидЦен, СтруктураОшибки, ПараметрыВнешнейСистемы, СтруктурнаяЕдиница, Клиент);
	
КонецФункции

// Процедура, получает структурурную единицу и эквайринговый терминал внешней системы.
//
Процедура ПолучитьСтруктурнуюЕдиницуИЭквайринговыйТерминалВС(ВнешняяСистема, СтруктурнаяЕдиница = Неопределено, ЭквайринговыйТерминал = Неопределено, Организация = Неопределено)
	
	api_ОбщегоНазначения.ПолучитьСтруктурнуюЕдиницуИЭквайринговыйТерминалВС(ВнешняяСистема, СтруктурнаяЕдиница, ЭквайринговыйТерминал, Организация);
	
КонецПроцедуры	

// Функция, получает эквайринговый терминал из внешней системы.
//
Функция ПолучитьЭквайринговыйТерминалИзВнешнейСистемы(ВнешняяСистема, СтруктурнаяЕдиница, Организация)
	
	Возврат Справочники.ВнешниеСистемы.ПолучитьЭквайринговыйТерминалИзВнешнейСистемы(ВнешняяСистема, СтруктурнаяЕдиница, Организация);
	
КонецФункции

Функция ПолучитьЗаявкуИлиКлиентаПоlead_id(lead_id, СтруктураОшибки)
	
	Если Не ЗначениеЗаполнено(lead_id) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Заявка = ПолучитьСсылкуПоИдентификатору_v3(lead_id, Новый Структура, Истина, "Заявки", 4030);
	
	Если Не ЗначениеЗаполнено(Заявка) Тогда
		
		Заявка = ПолучитьСсылкуПоИдентификатору_v3(lead_id, Новый Структура, Истина, "Контрагенты", 1010);
		
		Если Не ЗначениеЗаполнено(Заявка) Тогда
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(4030);
			Возврат Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Заявка;
	
КонецФункции

// Функция, возвращает структуру возврата ошибки. 
//
Функция ПолучитьСтруктуруОшибки_v2_удалить(КодОшибки = Неопределено, ОписаниеОшибки = "")
	
	Возврат api_ОбщегоНазначения.ПолучитьСтруктуруОшибки_v2(КодОшибки, ОписаниеОшибки);
	
КонецФункции

Функция СегментСодержитОбъект(Сегмент, Объект)
	
	Возврат РегистрыСведений.СоставСегментов.СегментСодержитОбъект(Сегмент, Объект);
	
КонецФункции

// Функция, возвращает массив помещений.
//
Функция ПолучитьПомещенияУслуги(Номенклатура)
	
	Возврат РегистрыСведений.ПомещенияДляОказанияУслуг.ПолучитьПомещенияУслуги(Номенклатура);
	
КонецФункции

// Функция, возвращает график работы структурной единицы за период.
//
Функция ПолучитьГрафикРаботыСтруктурнойЕдиницы(СтруктурнаяЕдиница, ДатаНачала, ДатаОкончания)
	
	Возврат Справочники.СтруктурныеЕдиницы.ПолучитьТаблицуГрафикаРаботыСтруктурнойЕдиницы(СтруктурнаяЕдиница, ДатаНачала, ДатаОкончания);
	
КонецФункции

// Функция, возвращает массив возможных операций над членством, пакетом услуг.
//
Функция ПолучитьМассивВозможныхОперацийНадЧПУ(ЧленствоПакетУслуг)
	
	ВозможныеОперацийНадЧленствомПакетомУслуг = ПолучитьСостояниеВозможныхОперацийНадЧленствамиПакетамиУслуг(ЧленствоПакетУслуг);
	
	МассивОпераций = Новый Массив;
	Если ВозможныеОперацийНадЧленствомПакетомУслуг.Активирование Тогда
		//МассивОпераций.Добавить("activation");  От кнопки Активирование в виджете избавились. Тикет 128024.
	ИначеЕсли ВозможныеОперацийНадЧленствомПакетомУслуг.Заморозка Тогда
		МассивОпераций.Добавить("freezing");
	ИначеЕсли ВозможныеОперацийНадЧленствомПакетомУслуг.Разморозка Тогда
		МассивОпераций.Добавить("defreezing");
	ИначеЕсли ВозможныеОперацийНадЧленствомПакетомУслуг.ОтменаЗаморозки Тогда
		МассивОпераций.Добавить("cancel_freezing");
	КонецЕсли;
	
	Возврат МассивОпераций;
	
КонецФункции

// Функция, возвращает массив структур заморозок.
//
Функция ПолучитьМассивСтруктурЗаморозок(ЧленствоПакетУслуг, НачалоПериода = Неопределено)
	
	ТаблицаЗаморозок 		 = ПолучитьТаблицуЗаморозок(ЧленствоПакетУслуг, НачалоПериода, Ложь);
	МассивСтруктурЗаморозок  = Новый Массив;
	ПоследняяСтрокаЗаморозки = Неопределено;
	
	Для Каждого СтрокаТЗ Из ТаблицаЗаморозок Цикл
		
		Если СтрокаТЗ.Ссылка.ВидОперации = Перечисления.ВидыОперацийСЧленствамиПакетамиУслуг.Разморозка
			И ПоследняяСтрокаЗаморозки <> Неопределено
			И ПоследняяСтрокаЗаморозки.ДатаОкончания > СтрокаТЗ.ДатаНачала Тогда
			
			ПоследняяСтрокаЗаморозки.ДатаОкончания = СтрокаТЗ.ДатаНачала;
		Иначе
			ПоследняяСтрокаЗаморозки = СтрокаТЗ;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого СтрокаТЗ Из ТаблицаЗаморозок Цикл
		
		Если СтрокаТЗ.Ссылка.ВидОперации = Перечисления.ВидыОперацийСЧленствамиПакетамиУслуг.Заморозка
			И НачалоДня(СтрокаТЗ.ДатаОкончания) >= НачалоДня(ТекущаяДатаСеанса()) Тогда
			
			СтруктураЗаморозки = Новый Структура;
			СтруктураЗаморозки.Вставить("id"		, Строка(СтрокаТЗ.Ссылка.УникальныйИдентификатор()));
			СтруктураЗаморозки.Вставить("start_date", СтрокаТЗ.ДатаНачала);
			СтруктураЗаморозки.Вставить("end_date"	, СтрокаТЗ.ДатаОкончания);
			СтруктураЗаморозки.Вставить("count"		, СтрокаТЗ.КоличествоДней);
			
			МассивСтруктурЗаморозок.Добавить(СтруктураЗаморозки);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МассивСтруктурЗаморозок;
	
КонецФункции

// Функция, возвращает таблицу не начатых заморозок.
//
Функция ПолучитьТаблицуЗаморозок(ЧленствоПакетУслуг, НачалоПериода = Неопределено, ВозвращатьТолькоБудущиеЗаморозки = Истина)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	СтатусыЧленствПакетовУслуг.Регистратор КАК Ссылка,
	|	ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).ДатаС КАК ДатаНачала,
	|	ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).ДатаПо КАК ДатаОкончания,
	|	ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).Срок КАК КоличествоДней
	|ИЗ
	|	РегистрСведений.СтатусыЧленствПакетовУслуг КАК СтатусыЧленствПакетовУслуг
	|ГДЕ
	|	СтатусыЧленствПакетовУслуг.ЧленствоПакетУслуг = &ЧленствоПакетУслуг
	|	И СтатусыЧленствПакетовУслуг.Регистратор ССЫЛКА Документ.ОперацииСЧленствомПакетомУслуг
	|	И (ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).ВидОперации = ЗНАЧЕНИЕ(Перечисление.ВидыОперацийСЧленствамиПакетамиУслуг.Заморозка)
	|				И СтатусыЧленствПакетовУслуг.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыЧленствПакетовУслуг.Заморожен)
	|				И &УсловиеНачалоПериода
	|			ИЛИ ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).ВидОперации = ЗНАЧЕНИЕ(Перечисление.ВидыОперацийСЧленствамиПакетамиУслуг.Разморозка))
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДатаНачала");
	
	Запрос.УстановитьПараметр("НачалоПериода"	  , НачалоПериода);
	Запрос.УстановитьПараметр("ЧленствоПакетУслуг", ЧленствоПакетУслуг);
	
	Если Не ЗначениеЗаполнено(НачалоПериода) Тогда
		УсловиеНачалоПериода = "";
	ИначеЕсли ВозвращатьТолькоБудущиеЗаморозки Тогда
		УсловиеНачалоПериода = "И (ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).ДатаС >= &НачалоПериода
							   |ИЛИ НачалоПериода(ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).ДатаС, День) = НачалоПериода(&НачалоПериода, День))";
	Иначе
		УсловиеНачалоПериода = "И ВЫРАЗИТЬ(СтатусыЧленствПакетовУслуг.Регистратор КАК Документ.ОперацииСЧленствомПакетомУслуг).ДатаПо > &НачалоПериода";
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "И &УсловиеНачалоПериода", УсловиеНачалоПериода);
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Функция, возвращает ссылку по УИД.
//
Функция ПолучитьСсылкуОбъектаПоУИД(УИД, ВидОбъекта, ИмяОбъекта)
	
	Возврат api_ОбщегоНазначения.ПолучитьСсылкуОбъектаПоУИД(УИД, ВидОбъекта, ИмяОбъекта);
	
КонецФункции

// Функция, возвращает структурные единицы внешней системы виджета расписания.
//
Функция ПолучитьСтруктурныеЕдиницыВнешнейСистемы(ВнешняяСистема)
	
	МассивСтруктурныхЕдиниц = Новый Массив;
	МассивПроверенныхСЕ     = Новый Массив;
	
	ПараметрыВнешнейСистемы = ВнешняяСистема.Параметры.Получить();
	МассивСЭС				= ПолучитьЗначениеИзСтруктуры(ПараметрыВнешнейСистемы, "МассивСтруктурноЭквайринговыхСоответствий", Новый Массив);
	
	Для Каждого ЭлементМ ИЗ МассивСЭС Цикл
		
		ТекущаяСЕ = ЭлементМ.СтруктурнаяЕдиница;
		Если Не ЗначениеЗаполнено(ТекущаяСЕ) ИЛИ МассивПроверенныхСЕ.Найти(ТекущаяСЕ) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивПроверенныхСЕ.Добавить(ТекущаяСЕ);
		МассивСтруктурныхЕдиниц.Добавить(Новый Структура("СтруктурнаяЕдиница, Наименование", ТекущаяСЕ, ПолучитьЗначениеРеквизита(ТекущаяСЕ, "Наименование")));
		
	КонецЦикла;
	
	Возврат МассивСтруктурныхЕдиниц;
	
КонецФункции	

// Функция, возвращает цвет занятия.
//
Функция ОпределитьЦветУслуги(ЦветФонаЗанятия, МакетСоответствиеЦветовWebИRGB = Неопределено)
	
	Возврат api_ОбщегоНазначения.ОпределитьЦветУслуги(ЦветФонаЗанятия, МакетСоответствиеЦветовWebИRGB);
	
КонецФункции

// Функция, возвращает таблицу номенклатур с ценами.
//
Функция ПолучитьЦенуНоменклкатуры_v2(МассивНоменклатур, СтруктурнаяЕдиница, ВидЦены)
		
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ВидЦены"           , ВидЦены);
	Запрос.УстановитьПараметр("МассивНоменклатур" , МассивНоменклатур);
	Запрос.УстановитьПараметр("СтруктурнаяЕдиница", СтруктурнаяЕдиница);
	Запрос.УстановитьПараметр("Дата"              , ТекущаяДатаСеанса());
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(СоставСегментов.Сегмент КАК Справочник.СегментыНоменклатуры) КАК СегментыНоменклатуры,
	|	ВЫРАЗИТЬ(СоставСегментов.ОбъектСегмента КАК Справочник.Номенклатура) КАК Номенклатура
	|ПОМЕСТИТЬ ТаблицаСегментовНоменклатуры
	|ИЗ
	|	РегистрСведений.СоставСегментов КАК СоставСегментов
	|ГДЕ
	|	СоставСегментов.ОбъектСегмента В(&МассивНоменклатур)
	|
	|СГРУППИРОВАТЬ ПО
	|	ВЫРАЗИТЬ(СоставСегментов.ОбъектСегмента КАК Справочник.Номенклатура),
	|	ВЫРАЗИТЬ(СоставСегментов.Сегмент КАК Справочник.СегментыНоменклатуры)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаСегментовНоменклатуры.Номенклатура КАК Номенклатура,
	|	&ВидЦены КАК ВидЦены
	|ПОМЕСТИТЬ ТаблицаНоменклатуры
	|ИЗ
	|	ТаблицаСегментовНоменклатуры КАК ТаблицаСегментовНоменклатуры
	|ГДЕ
	|	НЕ ТаблицаСегментовНоменклатуры.Номенклатура ЕСТЬ NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаНоменклатуры.Номенклатура КАК Номенклатура,
	|	ТаблицаНоменклатуры.Номенклатура.ПометкаУдаления КАК ПометкаУдаления,
	|	ВЫБОР
	|		КОГДА ТаблицаНоменклатуры.Номенклатура.Бесплатно
	|			ТОГДА 0
	|		ИНАЧЕ ЕСТЬNULL(ЦеныНоменклатурыСрезПоследних.Цена, НЕОПРЕДЕЛЕНО)
	|	КОНЕЦ КАК Цена
	|ИЗ
	|	ТаблицаНоменклатуры КАК ТаблицаНоменклатуры
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЦеныНоменклатуры.СрезПоследних(
	|				&Дата,
	|				СтруктурнаяЕдиница = &СтруктурнаяЕдиница
	|					И Номенклатура В
	|						(ВЫБРАТЬ
	|							ТаблицаНоменклатуры.Номенклатура
	|						ИЗ
	|							ТаблицаНоменклатуры)) КАК ЦеныНоменклатурыСрезПоследних
	|		ПО ТаблицаНоменклатуры.Номенклатура = ЦеныНоменклатурыСрезПоследних.Номенклатура
	|			И ТаблицаНоменклатуры.ВидЦены = ЦеныНоменклатурыСрезПоследних.ВидЦен
	|ИТОГИ
	|	МИНИМУМ(Цена)
	|ПО
	|	Номенклатура";
	
	
	МассивДопустимыхТипов = Новый Массив;
	МассивДопустимыхТипов.Добавить(Тип("Число"));
	МассивДопустимыхТипов.Добавить(Тип("Неопределено"));
	КЧ = Новый КвалификаторыЧисла(15,2);
	
	ТаблицаНоменклатуры = Новый ТаблицаЗначений;
	ТаблицаНоменклатуры.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));     
	ТаблицаНоменклатуры.Колонки.Добавить("ПометкаУдаления", Новый ОписаниеТипов("Булево"));
	ТаблицаНоменклатуры.Колонки.Добавить("Цена", Новый ОписаниеТипов(МассивДопустимыхТипов,,,КЧ));
	ТаблицаНоменклатуры.Колонки.Добавить("ВидЦен", Новый ОписаниеТипов("СправочникСсылка.ВидыЦен")); 	
	
	ВыборкаИтоги = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);	
	Пока ВыборкаИтоги.Следующий() Цикл
		Выборка = ВыборкаИтоги.Выбрать(ОбходРезультатаЗапроса.Прямой);
		Пока Выборка.Следующий() Цикл
			Если НЕ ВыборкаИтоги.Цена = Неопределено и ВыборкаИтоги.Цена = Выборка.Цена Тогда
				НоваяСтрока = ТаблицаНоменклатуры.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);			
				Прервать;
			КонецЕсли;
		КонецЦикла;		
	КонецЦикла;		
		
	Возврат ТаблицаНоменклатуры;
	
КонецФункции   

// Функция, проверяет переданный массив статусов.
//
Функция ПолучитьМассивСтатусов(statuses_ids, СтруктураОшибки = Неопределено)
	
	МассивСтатусов = Новый Массив;
	
	Если ЗначениеЗаполнено(statuses_ids) Тогда
		
		Если ТипЗнч(statuses_ids) = Тип("Массив") Тогда
			МассивПредставленийСтатусов = statuses_ids;
		Иначе
			МассивПредставленийСтатусов = Новый Массив;
			МассивПредставленийСтатусов.Добавить(statuses_ids);
		КонецЕсли;
		
		Для Каждого ПредставлениеСтатуса Из МассивПредставленийСтатусов Цикл
			
			Если ПредставлениеСтатуса = "planned" Тогда
				МассивСтатусов.Добавить(Перечисления.СтатусыЗанятия.Запланировано);
			ИначеЕсли ПредставлениеСтатуса = "ended" Тогда
				МассивСтатусов.Добавить(Перечисления.СтатусыЗанятия.Проведено);
			ИначеЕсли ПредставлениеСтатуса = "canceled" Тогда
				МассивСтатусов.Добавить(Перечисления.СтатусыЗанятия.Отменено);
			ИначеЕсли ПредставлениеСтатуса = "passes" Тогда
				МассивСтатусов.Добавить(Перечисления.СтатусыЗанятия.Проводится);
			Иначе
				СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1073);
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивСтатусов;
	
КонецФункции

// Функция, возвращает представление статуса прибытия.
//
Функция ПолучитьПредставлениеСтатусаПрибытия(СтатусПрибытия, СтатусЗанятия = Неопределено)
	
	Возврат api_ОбщегоНазначения.ПолучитьПредставлениеСтатусаПрибытия(СтатусПрибытия, СтатусЗанятия);
	
КонецФункции

// Функция, формирует представление сотрудника. 
//
Функция СформироватьПредставлениеСотрудника(ОнлайнБронированиеПредставление, Наименование)
	
	Возврат ?(ЗначениеЗаполнено(ОнлайнБронированиеПредставление), ОнлайнБронированиеПредставление, Наименование);
	
КонецФункции

// Функция возвращает визиты сотрудников
//
Функция ПолучитьЗаписиСотрудников(МассивСотрудников = Неопределено, СтруктурнаяЕдиница, НачалоПериода, КонецПериода, МассивПомещений = Неопределено, УчитыватьАренды = Ложь)
	
	Возврат api_ОбщегоНазначения.ПолучитьЗаписиСотрудников(МассивСотрудников, СтруктурнаяЕдиница, НачалоПериода, КонецПериода, МассивПомещений, УчитыватьАренды);
	
КонецФункции

// Функция, возвращает массив доступных для записи дней.
//
Функция ПолучитьМассивДоступныхДней(СтруктурнаяЕдиница, ДатаНачала, ДатаОкончания, Услуга, Сотрудник, СегментТренеров = Неопределено)
	
	Возврат api_ОбщегоНазначения.ПолучитьМассивДоступныхДней(СтруктурнаяЕдиница, ДатаНачала, ДатаОкончания, Услуга, Сотрудник, СегментТренеров);
	
КонецФункции

// Функция, возвращает длительность слота для записи.
//
Функция ПолучитьДлительностьСлота(СтруктурнаяЕдиница, Услуга = Неопределено, Сотрудник = Неопределено, Помещение = Неопределено)
	
	Возврат api_ОбщегоНазначения.ПолучитьДлительностьСлота(СтруктурнаяЕдиница, Услуга, Сотрудник, Помещение);
	
КонецФункции

// Функция, проверяет, входит ли запись в смену.
//
Функция ЗаписьВходитВСмену(Запись, Смена)
	
	Возврат ОбщегоНазначенияКлиентСервер.ПериодыПересекаются(Запись.ДатаВремяНачала, Запись.ДатаВремяОкончания, Смена.ДатаВремяНачала, Смена.ДатаВремяОкончания);
	
КонецФункции

// Функция, проверяет переданное основание оплаты.
//
Функция ПолучитьОснованиеОплаты_v3(ticket_id, СтруктураОшибки, ИскатьТакжеВводНачальныхОстатков = Ложь)
	
	ОснованиеОплаты = Неопределено;
	Если ЗначениеЗаполнено(ticket_id) Тогда
		
		ОснованиеОплаты = ПолучитьСсылкуОбъектаПоУИД(ticket_id, "Документы", "ЧленствоПакетУслуг");		
		Если ОснованиеОплаты = Неопределено Тогда
			
			ОснованиеОплаты = ПолучитьСсылкуОбъектаПоУИД(ticket_id, "Документы", "Реализация");
			Если ОснованиеОплаты = Неопределено И ИскатьТакжеВводНачальныхОстатков Тогда
				ОснованиеОплаты = ПолучитьСсылкуОбъектаПоУИД(ticket_id, "Документы", "ВводНачальныхОстатков");
			КонецЕсли;
			
			Если ОснованиеОплаты = Неопределено Тогда
				СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1050);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ОснованиеОплаты;
	
КонецФункции

// Функция, возвращает HTTPОтвет. 
//
Функция ПолучитьHTTPОтвет_удалить(Ответ1с, КодОтвета = Неопределено)
	
	Возврат api_ОбщегоНазначения.ПолучитьHTTPОтвет(Ответ1с, КодОтвета);
	
КонецФункции

// Функция, возвращает значение из структуры по ключу.
//
Функция ПолучитьЗначениеИзСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено)
	
	Если ТипЗнч(Структура) = Тип("Структура") Тогда
		Возврат ?(Структура.Свойство(Ключ), Структура[Ключ], ЗначениеПоУмолчанию);
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

// Функция, возвращает клиента по номеру телефона. 
// 
Функция ПолучитьКонтрагентаПоНомеруТелефона(знач НомерТелефона)
	
	Возврат api_ОбщегоНазначения.ПолучитьКонтрагентаПоНомеруТелефона(НомерТелефона);
	
КонецФункции

// Функция генерирует случайное число от 1000 до 9999
//
Функция СгенерироватьКодПодтверждения(ШестизначныйКод = Ложь)
	
	ГенераторСлучайныхЧисел  = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	
	Если ШестизначныйКод Тогда
		Возврат Формат(ГенераторСлучайныхЧисел.СлучайноеЧисло(100000, 999999), "ЧГ=0");
	Иначе
		Возврат Формат(ГенераторСлучайныхЧисел.СлучайноеЧисло(1000, 9999), "ЧГ=0");
	КонецЕсли;
	
КонецФункции

// Функция отправляет SMS-сообщение или сообщение в мессенджер 
//
Функция ОтправитьСообщение(Контрагент, Телефон, Содержание, СтруктурнаяЕдиница, ВнешняяСистема)
	
	ПОПЫТКА
		
		// Получаем параметры личного кабинета
		ПараметрыЛК = ВнешняяСистема.Параметры.Получить(); 
		
		ОтправлятьВМессенджер = ?(ЗначениеЗаполнено(ПараметрыЛК), ПараметрыЛК.Свойство("ОтправлятьКодПодтвержденияВМессенджер") И ПараметрыЛК.ОтправлятьКодПодтвержденияВМессенджер, Ложь);
		
		Если ОтправлятьВМессенджер = Истина Тогда  			
			// Получим Внешнюю систему мессенджера по структурной единице.
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(Перечисления.ТипыВнешнихСистем.Chat2Desk);
			МассивТипов.Добавить(Перечисления.ТипыВнешнихСистем.IntellectDialog);
			МассивТипов.Добавить(Перечисления.ТипыВнешнихСистем.ChatApi);
			СервисРассылки   = Справочники.ВнешниеСистемы.ПолучитьВнешнююСистему(,МассивТипов, Истина, СтруктурнаяЕдиница); 				
			Если ЗначениеЗаполнено(СервисРассылки) Тогда
				ПараметрыСервиса = СервисРассылки.Параметры.Получить();
				ИдКанала         = ?(НЕ ПараметрыСервиса = Неопределено И ПараметрыСервиса.Свойство("ChannelId"), ПараметрыСервиса.ChannelId, "");
			КонецЕсли;
		КонецЕсли;		
		
		// Если Сервис не заполнен, то берем sms.
		Если НЕ ЗначениеЗаполнено(СервисРассылки) Тогда
			СервисРассылки = ?(ЗначениеЗаполнено(СтруктурнаяЕдиница), СтруктурнаяЕдиница.СервисSMSРассылки, Неопределено);
			СервисРассылки = ?(Не ЗначениеЗаполнено(СервисРассылки), Константы.СервисSMSРассылкиПоУмолчанию.Получить(), СервисРассылки);			
		КонецЕсли;
		
		РассылкаСообщений = Документы.РассылкаСообщений.СоздатьДокумент();
		
		РассылкаСообщений.Дата 			 	  = ТекущаяДатаСеанса();
		РассылкаСообщений.СтруктурнаяЕдиница  = СтруктурнаяЕдиница;
		РассылкаСообщений.ВидОперации 		  = Перечисления.ВидОперацииОтправкаСообщений.ОтправкаПолучателю;
		РассылкаСообщений.ОтправитьНемедленно = Истина;
		РассылкаСообщений.Содержание 		  = Содержание;
		
		НоваяСтрока 			   = РассылкаСообщений.Получатели.Добавить();
		НоваяСтрока.Получатель 	   = Контрагент;
		НоваяСтрока.НомерТелефона  = Телефон; 
		НоваяСтрока.СервисРассылки = СервисРассылки; 
		// Заполняем Ид Канала для мессендежера.
		НоваяСтрока.ИдКанала       = ?(ТипЗнч(СервисРассылки) = Тип("СправочникСсылка.ВнешниеСистемы"), ИдКанала, "");
		
		РассылкаСообщений.ДополнительныеСвойства.Вставить("ОтправитьКодПодтверждения", Истина);
		
		РассылкаСообщений.Записать(РежимЗаписиДокумента.Запись);
		РассылкаСообщений.Записать(РежимЗаписиДокумента.Проведение);		
		
	ИСКЛЮЧЕНИЕ
		
		ЗаписьЖурналаРегистрации("api_v3", УровеньЖурналаРегистрации.Ошибка, РассылкаСообщений.Метаданные(), РассылкаСообщений.Ссылка, ОписаниеОшибки());
		Возврат "Ошибка при отправке сообщения с кодом подтверждения. " + ОписаниеОшибки();
		
	КОНЕЦПОПЫТКИ;
	
	Возврат Неопределено;
	
КонецФункции

// Функция, находит или создает рекламный источник по наименованию.
//
Функция ПолучитьРекламныйИсточник(Наименование)
	
	Возврат Справочники.РекламныеИсточники.ПолучитьРекламныйИсточник(Наименование);
	
КонецФункции

// Функция, создает входящую заявку.
//
Функция СоздатьВходящуюЗаявку(Фамилия, Имя, Отчество, phone, email, РекламныйИсточник, РекламнаяСсылка, ПараметрыUTM, ВнешняяСистема, Комментарий = Неопределено, Клиент = Неопределено, СтруктурнаяЕдиница, КлиентИзВиджетаЛК = Неопределено, РекламнаяПлощадка = Неопределено)
	
	Возврат Справочники.Заявки.СоздатьВходящуюЗаявку(,,, Фамилия, Имя, Отчество, phone, email, РекламныйИсточник, РекламнаяПлощадка, РекламнаяСсылка, Комментарий, ПараметрыUTM, ВнешняяСистема,, Клиент, СтруктурнаяЕдиница, КлиентИзВиджетаЛК);
	
КонецФункции

// Процедура, выполняет смену идентификации. 
//
Процедура СменитьОбъектИдентификации(ИдКлиента, КлиентСсылка, ВнешняяСистема)
	
	РегистрыСведений.КонтактыМессенджеров.СменитьОбъектИдентификации(ИдКлиента, КлиентСсылка, ВнешняяСистема);	
	
КонецПроцедуры	

// Функция, создает потенциального клиента.
//
Функция СоздатьКлиента(ПараметрыКлиента, СтруктурнаяЕдиница, НастройкиAPI, НаименованиеКаналаПривлечения = "", ВнешняяСистема = Неопределено)
	
	КлиентОбъект = Справочники.Контрагенты.СоздатьЭлемент();
	КлиентОбъект.Фамилия  = ПараметрыКлиента.LastName;
	КлиентОбъект.Имя      = ПараметрыКлиента.Name;
	КлиентОбъект.Отчество = ПараметрыКлиента.SecondName;
	Попытка
		Если ЗначениеЗаполнено(ПараметрыКлиента.Birthday) Тогда
			КлиентОбъект.ДатаРожденияКлиента = Дата(Сред(ПараметрыКлиента.Birthday,1,4), Сред(ПараметрыКлиента.Birthday,6,2), Сред(ПараметрыКлиента.Birthday,9)); 
		КонецЕсли;
	Исключение
	КонецПопытки;
	КлиентОбъект.Наименование 		= СформироватьНаименованиеКлиента(КлиентОбъект);
	КлиентОбъект.ТипКонтрагента 	= Перечисления.ТипыКонтрагентов.Клиенты;
	КлиентОбъект.ЮрФизЛицо 			= Перечисления.ЮрФизЛицо.ФизЛицо;
	КлиентОбъект.ДатаРегистрации 	= ТекущаяДатаСеанса();
	КлиентОбъект.СтруктурнаяЕдиница = СтруктурнаяЕдиница;
	КлиентОбъект.ОнлайнРегистрация  = Истина;
	Если ЗначениеЗаполнено(НаименованиеКаналаПривлечения) Тогда
		КлиентОбъект.КаналПривлечения = ПолучитьКаналПривлечения(НаименованиеКаналаПривлечения);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(НастройкиAPI) Тогда
		КлиентОбъект.Родитель = НастройкиAPI.ПапкаКлиентов; 
	Иначе
		КлиентОбъект.Родитель = Справочники.Контрагенты.ПолучитьПапкуПоТипу(Перечисления.ТипыКонтрагентов.Клиенты);
	КонецЕсли;
	
	Если ПараметрыКлиента.Свойство("Promocode") Тогда
		КлиентОбъект.Промокод = ПараметрыКлиента.Promocode;
	КонецЕсли;
	
	Если ПараметрыКлиента.Свойство("Phone") И ЗначениеЗаполнено(ПараметрыКлиента.Phone) Тогда
		api_ОбщегоНазначения.ДобавитьНомерТелефонаВКонтактнуюИнформациюКлиента(КлиентОбъект, ПараметрыКлиента.Phone);
	КонецЕсли;
		
	Если ПараметрыКлиента.Свойство("Email") И ЗначениеЗаполнено(ПараметрыКлиента.Email) Тогда
		ДобавитьEmailВКонтактнуюИнформациюКлиента(КлиентОбъект, ПараметрыКлиента.Email);
	КонецЕсли;
	
	КлиентОбъект.ПолКлиента 	= ПолучитьПолКлиента(ПараметрыКлиента.Sex, ПараметрыКлиента.LastName, ПараметрыКлиента.Name, ПараметрыКлиента.SecondName);
	КлиентОбъект.ВнешняяСистема = ВнешняяСистема;
	
	Попытка
		КлиентОбъект.Записать();
	Исключение
		Инф = ОписаниеОшибки();
	КонецПопытки;
	
	СтатусыКонтрагентовМенеджерЗаписи = РегистрыСведений.СтатусыКонтрагентов.СоздатьМенеджерЗаписи();
	СтатусыКонтрагентовМенеджерЗаписи.Период 	 = ТекущаяДатаСеанса();
	СтатусыКонтрагентовМенеджерЗаписи.Контрагент = КлиентОбъект.Ссылка;
	СтатусыКонтрагентовМенеджерЗаписи.Статус 	 = Перечисления.СтатусыКлиентов.ПотенциальныйЧленКлуба;
	СтатусыКонтрагентовМенеджерЗаписи.Записать(); 	
	
	Если ЗначениеЗаполнено(НастройкиAPI) Тогда
		api_ОбщегоНазначения.СоздатьЛицевойСчетКлиента(КлиентОбъект.Ссылка, НастройкиAPI.ВидЛицевогоСчета);
	КонецЕсли;
	
	Возврат КлиентОбъект.Ссылка;	
	
КонецФункции

// Функция, проверяет переданный лицевой счет.
//
Функция ПолучитьЛицевойСчетИлиВидСчета(deposit_id, СтруктураОшибки)
	
	ЛицевойСчет = ПолучитьСсылкуОбъектаПоУИД(deposit_id, "Справочники", "ЛицевыеСчета");
	Если ЛицевойСчет = Неопределено Тогда
		ЛицевойСчет = ПолучитьСсылкуОбъектаПоУИД(deposit_id, "Справочники", "ВидыЛицевыхСчетов");
		Если ЛицевойСчет = Неопределено Тогда
			СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(1011);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЛицевойСчет;
	
КонецФункции

// Процедура, устанавливает блокировку на занятие.
//
Процедура УстановитьБлокировкуЗанятия(Занятие)
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Документ.Занятие");
	ЭлементБлокировки.УстановитьЗначение("Ссылка", Занятие);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Процедура, устанавливает блокировку.
Процедура УстановитьБлокировку(БлокируемыйДокумент, РеквизитБлокировки, ЗначениеРеквизита)
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(БлокируемыйДокумент);
	ЭлементБлокировки.УстановитьЗначение(РеквизитБлокировки, ЗначениеРеквизита);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Функция, добавления (изменения или удаления) структурной единицы
//
Функция ПроверитьНаДубликатПоступления(Организация = Неопределено, IDTransaction, СтруктураОшибки)
	
	НаличиеДубликата = api_ОбщегоНазначения.НаличиеДубликатаПоступления(Организация, IDTransaction);
	
	Если НаличиеДубликата Тогда
		СтруктураОшибки 	   = ПолучитьСтруктуруОшибки_v2(1018);
		СтруктураОшибки.result = Истина;
	КонецЕсли;
	
	Возврат НаличиеДубликата
	
КонецФункции

// Функция, возвращает кассу оплаты по эквайринговому терминалу.
//
Функция ПолучитьКассуОплатыИПараметрыФискализации(ЭквайринговыйТерминал, ПараметрыФискализации)
	
	Возврат Справочники.Кассы.ПолучитьКассуОплатыИПараметрыФискализации(ЭквайринговыйТерминал, ПараметрыФискализации);
	
КонецФункции

// Функция, находит или создает лицевой счет.
//
Функция ПолучитьЛицевойСчет(ЛицевойСчетИлиВидСчета, Клиент)
	
	Возврат api_ОбщегоНазначения.ПолучитьЛицевойСчет(ЛицевойСчетИлиВидСчета, Клиент);
	
КонецФункции

Процедура ОтправитьПлатежиВLifePay(ПоступлениеНаСчет, КассаОплаты)
	
	api_ОбщегоНазначения.ОтправитьПлатежиВLifePay(ПоступлениеНаСчет, КассаОплаты, Ложь, "api_v3");
	
КонецПроцедуры

Процедура ОтправитьПлатежиВCloudKassir(ПоступлениеНаСчетИлиРеализация, КассаОплаты)
	
	api_ОбщегоНазначения.ОтправитьПлатежиВCloudKassir(ПоступлениеНаСчетИлиРеализация, КассаОплаты, "api_v3");
	
КонецПроцедуры

// Функция, проверяет возможность резерва занятия клиентом.
//
Функция ВозможенРезервЗанятияКлиентом(СтруктурнаяЕдиница, Клиент, ОписаниеОшибки, НастройкиAPI, ДатаРезерва, ИсключаемоеЗанятие = Неопределено)
	
	Возврат api_ОбщегоНазначения.ВозможенРезервЗанятияКлиентом(СтруктурнаяЕдиница, Клиент, ОписаниеОшибки, НастройкиAPI, ДатаРезерва, ИсключаемоеЗанятие);
	
КонецФункции

// Функция, проверяет наличие временных ограничений для онлайн записи.
//
Функция НаличиеОграниченияНаОнлайнЗапись(Занятие = Неопределено, ТекстСообщения = Неопределено, ДатаВремяЗаписи = Неопределено, Номенклатура = Неопределено)
	
	Возврат api_ОбщегоНазначения.НаличиеОграниченияНаОнлайнЗапись(Занятие, ТекстСообщения, ДатаВремяЗаписи, Номенклатура);
	
КонецФункции

// Функция, возвращает источник записи по внешней системе.
//
Функция ПолучитьИсточникЗаписи(ВнешняяСистема);

	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ИсточникиЗаписей.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ИсточникиЗаписей КАК ИсточникиЗаписей
	|ГДЕ
	|	НЕ ИсточникиЗаписей.ПометкаУдаления
	|	И ИсточникиЗаписей.ВнешняяСистема = &ВнешняяСистема");
	
	Запрос.УстановитьПараметр("ВнешняяСистема", ВнешняяСистема);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	Иначе
		Возврат Справочники.ИсточникиЗаписей.СоздатьИсточникЗаписей(ВнешняяСистема, ВнешняяСистема.Наименование);	
	КонецЕсли;	
	
КонецФункции	

// Процедура, обрабатывает строку без основания оплаты.
//
Процедура ЗаписьКлиентаНаЗанятиеОбработатьСтрокуБезОснованияОплаты(ЗанятиеОбъект, СтрокаЗанятия, ВнешняяСистема)
		
	Если Не ЗначениеЗаполнено(СтрокаЗанятия.ВидЦен) Тогда
		СтрокаЗанятия.ВидЦен = Ценообразование.ВидЦеныНоменклатурыПоУмолчанию(ЗанятиеОбъект.СтруктурнаяЕдиница, ЗанятиеОбъект.Сотрудник, СтрокаЗанятия.Договор);
	КонецЕсли;
	
	// Поиск пробных пакетов по данной услуге занятия.
	ДанныеПробногоПакета = Документы.Занятие.ПробныйПакетУслугДляПродажиИзЗанятия(
		ЗанятиеОбъект.Номенклатура, 
		ЗанятиеОбъект.Дата, 
		ЗанятиеОбъект.СтруктурнаяЕдиница, 
		ЗанятиеОбъект.Сотрудник, 
		СтрокаЗанятия.Контрагент, 
		ЗанятиеОбъект.ДатаВремяНачала, 
		ЗанятиеОбъект.ДатаВремяОкончания,
		СтрокаЗанятия.ВидЦен
	);  
	
	Если ЗначениеЗаполнено(ДанныеПробногоПакета) 
		И ЗначениеЗаполнено(ДанныеПробногоПакета.Номенклатура) Тогда 
		
		ДополнительныеПараметры = Новый Структура;
		ДополнительныеПараметры.Вставить("СтруктурнаяЕдиница"	, ЗанятиеОбъект.СтруктурнаяЕдиница);
		ДополнительныеПараметры.Вставить("ВремяНачалаЗанятия"	, ЗанятиеОбъект.ДатаВремяНачала);
		ДополнительныеПараметры.Вставить("ВремяОкончанияЗанятия", ЗанятиеОбъект.ДатаВремяОкончания);
		ДополнительныеПараметры.Вставить("ВнешняяСистема"		, ВнешняяСистема);
		
		СтрокаЗанятия.ОснованиеОплаты = Документы.Занятие.СоздатьРеалзиациюДляЗакрытияОснованияОплаты(
			?(ЗанятиеОбъект.Дата > ТекущаяДатаСеанса(), НачалоДня(ЗанятиеОбъект.Дата), ЗанятиеОбъект.Дата),
			СтрокаЗанятия.Контрагент,
			СтрокаЗанятия.Договор,
			ДанныеПробногоПакета.Номенклатура,
			СтрокаЗанятия.Количество,
			СтрокаЗанятия.ВидЦен,
			ЗанятиеОбъект.Сотрудник,
			ДополнительныеПараметры
		);
		
		СтрокаЗанятия.ДатаБронирования = ?(ЗначениеЗаполнено(СтрокаЗанятия.ОснованиеОплаты), Неопределено, СтрокаЗанятия.ДатаБронирования);
		
	КонецЕсли;

КонецПроцедуры

// Функция - Извлечь код ошибки нижнего уровня
//
// Параметры:
//  ТекстОшибки	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция ИзвлечьКодОшибкиНижнегоУровня(знач ТекстОшибки) 
	
	Попытка 
		
		КодОшибкиИзОбъекта = Неопределено;
		
		Если СтрНайти(ТекстОшибки, "[") > 0 Тогда
			
			Начало = СтрНайти(ТекстОшибки,"[");
			Конец = СтрНайти(ТекстОшибки,"]",НаправлениеПоиска.СКонца);
			Если Начало > 0 
				И Конец > 0 Тогда
				
				КодОшибкиИзОбъекта = Сред(ТекстОшибки, Начало + 1, Конец - Начало - 1);
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "[" + КодОшибкиИзОбъекта + "]", "");
				
			КонецЕсли;
			
			Возврат Новый Структура("ТекстОшибки,КодОшибки", ТекстОшибки, Число(КодОшибкиИзОбъекта));
			
		КонецЕсли;
		
	Исключение
		
	КонецПопытки;
	
	Возврат Неопределено;
КонецФункции

// Функция, проверяет переданную дату.
//
Функция ПолучитьПереданнуюДату(date, СтруктураОшибки)
	
	ДатаАктивации = КонвертироватьСтрокуВДату(date);
	
	Если ДатаАктивации = Неопределено Тогда
		СтруктураОшибки = ПолучитьСтруктуруОшибки_v2(2017);
	КонецЕсли;
	
	Возврат ДатаАктивации;
	
КонецФункции

// Функция, возваращает флаг возможности разморозить членство.
//
Функция ПроверкаРазмарозкиЗаморозкиЧленства(ВидОперации, ЧленствоПакетУслуг, ДатаС, ДатаПо, Срок, Описание = "", Статус = Неопределено)
	
	Возврат api_ОбщегоНазначения.ПроверкаРазмарозкиЗаморозкиЧленства(ВидОперации, ЧленствоПакетУслуг, ДатаС, ДатаПо, Срок, Описание, Статус);
	
КонецФункции

// Функция, выполянет отмену замарозки.
//
Функция ОтменаРазморозки(ЧленствоПакетУслуг, Дата)
	
	Заморозка = Документы.ОперацииСЧленствомПакетомУслуг.ПолучитьАктуальнуюЗаморозку(КонецДня(Дата), ЧленствоПакетУслуг);
	
	Если ЗначениеЗаполнено(Заморозка) Тогда
		Попытка
			ОперацияСЧленствомОбъект = Заморозка.ПолучитьОбъект();
			ОперацияСЧленствомОбъект.Записать(РежимЗаписиДокумента.ОтменаПроведения);
		Исключение
			Возврат Ложь;
		КонецПопытки;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;	
	
КонецФункции

Функция РассчитатьКоличествоУслуг(Длительность, Номенклатура)
	
	НормаВремени = ?(Длительность = Неопределено, Номенклатура.НормаВремени, Длительность);
	
	Если Номенклатура.ТипВременнойТарификации = Перечисления.ТипыВременнойТарификации.Почасовая
		ИЛИ Номенклатура.ТипВременнойТарификации = Перечисления.ТипыВременнойТарификации.Поминутная Тогда
		
		Возврат НормаВремени;
	Иначе
		Возврат ?(Длительность = Неопределено ИЛИ НормаВремени = 0, 1, Длительность / НормаВремени);
	КонецЕсли;
	
КонецФункции

// Функция, проверяет переданный массив оплат.
//
Функция ПроверитьМассивСтруктурОплат_v3(Клиент, payment_list, ЭквайринговыйТерминал, КассаОплаты, СтруктураОшибки)
	
	Возврат api_ОбщегоНазначения.ПроверитьМассивСтруктурОплат_v3(Клиент, payment_list, ЭквайринговыйТерминал, КассаОплаты, СтруктураОшибки);
	
КонецФункции

// Функция, возвращает таблицу задолженностей.
//
Функция ПолучитьЗадолженностиДляМассиваДокументов(МассивРеализаций)
	
	Возврат РегистрыНакопления.РасчетыСПокупателями.ПолучитьЗадолженностиДляМассиваДокументов(ТекущаяДатаСеанса(), МассивРеализаций);
	
КонецФункции

// Функция, возвращает пол клиента.
//
Функция ПолучитьПолКлиента(Sex, LastName, Name, SecondName)
	
	Возврат api_ОбщегоНазначения.ПолучитьПолКлиента(Sex, LastName, Name, SecondName);
	
КонецФункции

// Процедура, добавляет email в табличную часть "КонтактнаяИнформация".
//
Процедура ДобавитьEmailВКонтактнуюИнформациюКлиента(КлиентОбъект, АдресЭП)
	
	api_ОбщегоНазначения.ДобавитьEmailВКонтактнуюИнформациюКлиента(КлиентОбъект, АдресЭП);
	
КонецПроцедуры

// Функция, возвращает канал привлечения.
//
Функция ПолучитьКаналПривлечения(Наименование)
	
	Возврат Справочники.КаналыПривлечения.ПолучитьКаналПривлечения(Наименование);
	
КонецФункции

// Функция, возвращает структуру контактной информации.
//
Функция ПолучитьКонтактнуюИнформацию(Клиент)
	
	МассивEmail   = api_ОбщегоНазначения.ПолучитьСтрокиКонтактнойИнформации(Клиент, Неопределено, Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты, "АдресЭП");
	МассивТелефон = api_ОбщегоНазначения.ПолучитьСтрокиКонтактнойИнформации(Клиент, Неопределено, Перечисления.ТипыКонтактнойИнформации.Телефон			  	 , "НомерТелефона");
	
	Возврат Новый Структура("Email, Телефон", МассивEmail, МассивТелефон);
	
КонецФункции

// Функция, конвертирует строку в дату.
//
Функция КонвертироватьСтрокуВДату(Дата)
	
	Возврат api_ОбщегоНазначения.КонвертироватьСтрокуВДату(Дата);
	
КонецФункции

// Функция, возвращает дату.
//
Функция ПолучитьНачалоПериодаПопериодичности(ДатаЗаписи, ПосещенийНеЧащеТип)
	
	Если ПосещенийНеЧащеТип = Перечисления.Периодичность.Месяц Тогда				
		Возврат НачалоМесяца(ДатаЗаписи);
	ИначеЕсли ПосещенийНеЧащеТип = Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНедели(ДатаЗаписи);
	Иначе
		Возврат НачалоДня(ДатаЗаписи);
	КонецЕсли;
	
КонецФункции

// Функция, возвращает возможные операции над членством пакетом услуг.
//
Функция ПолучитьСостояниеВозможныхОперацийНадЧленствамиПакетамиУслуг(ЧленствоПакетУслуг)
	
	Возврат Документы.ЧленствоПакетУслуг.ПолучитьСостояниеВозможныхОперацийНадЧленствамиПакетамиУслуг(, ЧленствоПакетУслуг, Истина);
	
КонецФункции

// Функция, возвращает наименование клиента.
//
Функция СформироватьНаименованиеКлиента(Клиент)
	
	Возврат СокрЛП(Клиент.Фамилия) + ?(ЗначениеЗаполнено(Клиент.Фамилия), " ", "") + СокрЛП(Клиент.Имя) + ?(ЗначениеЗаполнено(Клиент.Имя), " ", "") + СокрЛП(Клиент.Отчество);
	
КонецФункции

// Функция, возвращает организацию для оплаты.
//
Функция ПолучитьIDОрганизацииДляОплаты(МассивРеализаций)
	
	IDОрганизации = Неопределено;
	
	Для Каждого Реализация из МассивРеализаций Цикл
		
		Организация = ОбщегоНазначения.ПолучитьЗначениеРеквизита(Реализация, "Организация");
		Если ЗначениеЗаполнено(Организация) Тогда
			IDОрганизации = Строка(Организация.УникальныйИдентификатор());
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат IDОрганизации;
	
КонецФункции

// Функция, проверяет входит ли IP адрес в доверенные IP адреса.
//
Функция ПроверитьДоверенныйIpАдрес(ДоверенныеIPАдреса, IPАдрес) 
	
	Для Каждого Строка Из ДоверенныеIPАдреса Цикл
		
		Если ТипЗнч(Строка) = Тип("Структура") И Строка.Свойство("IPАдрес") И ЗначениеЗаполнено(Строка.IPАдрес)
			И Строка.IPАдрес = IPАдрес Тогда
			
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти



















